J2EE笨重的开发、繁多的配置、低下的开发效率、复杂的部署流程、第三方技术集成难度大。
Spring Boot简化Spring应用开发，约定大于配置。

Spring Boot -> J2EE一站式解决方案
Spring Cloud -> 分布式整体解决方案

优点：
	– 快速创建独立运行的Spring项目以及与主流框架集成
	– 使用嵌入式的Servlet容器，应用无需打成WAR包
	– starters自动依赖与版本控制
	– 大量的自动配置，简化开发，也可修改默认值
	– 无需配置XML，无代码生成，开箱即用
	– 准生产环境的运行时应用监控
	– 与云计算的天然集成

=============================================================================

@SpringBootApplication
	@SpringBootConfiguration
		@Configuration
			@Component
	@EnableAutoConfiguration
		@AutoConfigurationPackage
			@Import(AutoConfigurationPackages.Registrar.class)//将主配置类（@SpringBootApplication标注的类）所在的包及子包里的组件扫描到Spring容器
		@Import(EnableAutoConfigurationImportSelector.class)//给容器中导入很多场景需要的自动配置类（xxxAutoConfiguration）
															//从类路径下META-INF/spring.factories（spring-boot-autoconfigure-1.5.19.RELEASE.jar里）中获取EnableAutoConfiguration的值，将这些自动配置类导入到容器中

<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-parent</artifactId>
	<version>1.5.19.RELEASE</version>
</parent>

他的父项目是
<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-dependencies</artifactId>
	<version>1.5.9.RELEASE</version>
	<relativePath>../../spring-boot-dependencies</relativePath>
</parent>
他来真正管理Spring Boot应用里面的所有依赖版本

场景启动器
Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器

resources文件夹中目录结构
	static：保存所有的静态资源， js css images
	templates：保存所有的模板页面（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面），可以使用模板引擎（freemarker、thymeleaf）
	application.properties：Spring Boot应用的配置文件，可以修改一些默认设置

=============================================================================
配置文件

SpringBoot使用一个全局的配置文件，配置文件名是固定的
application.properties
application.yml

配置文件的作用：修改SpringBoot自动配置的默认值

YAML（YAML Ain't Markup Language）
	YAML - Markup Language：是一个标记语言
	YAML - isn't Markup Language：不是一个标记语言

标记语言：
	以前的配置文件，大多都使用的是 xxxx.xml文件
	YAML：以数据为中心，比json、xml等更适合做配置文件

YAML语法：

1、基本语法
key:(空格)value
表示一对键值对（空格必须有）
以空格的缩进来控制层级关系，只要是左对齐的一列数据，都是同一个层级的
属性和值也是大小写敏感

2、值的写法
a)字面量：普通的值（数字，字符串，布尔）

	k: v，字面直接来写；

		字符串默认不用加上单引号或者双引号
		""：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思
				name: "zhangsan \n lisi"，输出；zhangsan 换行  lisi
		''：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据
				name: ‘zhangsan \n lisi’，输出；zhangsan \n lisi

b)对象、Map（属性和值）（键值对）：
	k: v，在下一行来写对象的属性和值的关系，注意缩进，对象还是k: v的方式
	friends:
	  lastName: zhangsan
	  age: 20

	行内写法：
	friends: {lastName: zhangsan, age: 18}

c)数组（List、Set）：
	用- 值表示数组中的一个元素
	pets:
	 - cat
	 - dog
	 - pig
	
	行内写法
	pets: [cat, dog, pig]


${} @Value取值
#{} SpEL表达式

如果在编辑配置文件的时候提示Spring Boot Configuration Annotation Processor not found in classpath
导入配置文件处理器，配置文件进行绑定就会有提示
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-configuration-processor</artifactId>
	<optional>true</optional>
</dependency>

properties编码
三个都是utf-8，打上勾

将配置文件中配置的每一个属性的值，映射到组件中
@ConfigurationProperties
将本类中的所有属性和配置文件中相关的配置进行绑定
prefix = "person"
配置文件中哪个下面的所有属性进行一一映射

				@ConfigurationProperties	@Value
功能				批量注入配置文件中的属性		一个个指定
松散绑定			支持							不支持
SpEL			不支持						支持
JSR303数据校验	支持							不支持
复杂类型封装		支持							不支持

从全局配置文件中取值
配置文件yml还是properties他们都能获取到值
如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value
如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties

松散绑定（Relaxed binding）
last-name和lastName一样

属性名匹配规则
person.firstName：使用标准方式
person.first-name：大写用-
person.first_name：大写用_
PERSON_FIRST_NAME：推荐系统属性使用这种写法


@PropertySource：加载指定的配置文件
@PropertySource(value = {"classpath:person.properties"})


@ImportResource：导入Spring的配置文件，让配置文件里面的内容生效
Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别
想让Spring的配置文件生效，加载进来，@ImportResource标注在一个配置类上，可以在主配置类上
@ImportResource(locations = {"classpath:beans.xml"})

不来编写Spring的配置文件

SpringBoot推荐使用全注解的方式给容器中添加组件
1、配置类@Configuration相当于Spring配置文件
2、使用@Bean给容器中添加组件

@Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件
@Bean：将方法的返回值添加到容器中，容器中这个组件id默认是方法名


3、配置文件注入值数据校验
@Validated
public class Person {
	@Email
	@Value("${person.lastName}")
	private String lastName;
}


4、配置文件占位符
占位符获取之前配置的值，如果没有可以是用:指定默认值
也可以用随机数
${random.value}、${random.int}、${random.long}
${random.int(10)}、${random.int[1024,65536]}

person.name=zhangsan
person.dog.name=${person.name:hello}_dog


5、Profile
多Profile文件
我们在主配置文件编写的时候，文件名可以是application-{profile}.properties/yml
默认使用application.properties的配置

yml支持多文档块方式
server:
  port: 8080
spring:
  profiles:
    active: prod
---
server:
  port: 8081
spring:
  profiles: dev
---
server:
  port: 8082
spring:
  profiles: prod #指定属于哪个环境

激活指定profile
	1、在配置文件中指定spring.profiles.active=dev
	2、命令行：
		java -jar xxx.jar --spring.profiles.active=dev
	3、虚拟机参数；
		-Dspring.profiles.active=dev


6、配置文件加载位置
springboot启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件
	file:./config/
	file:./
	classpath:/config/
	classpath:/
优先级从高到低，高优先级的配置会覆盖低优先级的配置，所有的配置会形成互补配置

我们还可以通过spring.config.location来改变默认的配置文件位置
项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置，指定配置文件和默认加载的这些配置文件共同起作用形成互补配置
java -jar xxx.jar --spring.config.location=d:/application.properties


7、外部配置加载顺序
SpringBoot也可以从以下位置加载配置
优先级从高到低，高优先级的配置会覆盖低优先级的配置，所有的配置会形成互补配置

1.命令行参数
	所有的配置都可以在命令行上进行指定
	java -jar xxx.jar --server.port=8087 --server.context-path=/abc
	多个配置用空格分开，--配置项=值

2.来自java:comp/env的JNDI属性
3.Java系统属性（System.getProperties()）
4.操作系统环境变量
5.RandomValuePropertySource配置的random.*属性值

6.jar包外部的application-{profile}.properties/yml
7.jar包内部的application-{profile}.properties/yml
8.jar包外部的application.properties/yml
9.jar包内部的application.properties/yml
	先加载带profile，再加载不带profile
	先加载jar包外部，再加载jar包内部
	
10.@Configuration注解类上的@PropertySource
11.通过SpringApplication.setDefaultProperties指定的默认属性

8、自动配置原理
配置文件到底能写什么？怎么写？
https://docs.spring.io/spring-boot/docs/1.5.19.RELEASE/reference/htmlsingle/#common-application-properties

1、自动配置原理：
1）SpringBoot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration
2）@EnableAutoConfiguration 作用：
	利用EnableAutoConfigurationImportSelector给容器中导入一些组件
	可以查看selectImports()方法的内容
	List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置
	SpringFactoriesLoader.loadFactoryNames();
	扫描所有jar包类路径下  META-INF/spring.factories
	把扫描到的这些文件的内容包装成properties对象
	从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加到容器中
	将类路径下 META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值加入到了容器中
	每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置
3）每一个自动配置类进行自动配置功能；
4）以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理

	//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件
	@Configuration
	
	//启动指定类的ConfigurationProperties功能，将配置文件中对应的值和HttpEncodingProperties绑定起来，并把HttpEncodingProperties加入到ioc容器中
	@EnableConfigurationProperties(HttpEncodingProperties.class)
	
	//Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，这个配置类里面的配置就会生效
	//判断当前应用是否是web应用，如果是，当前配置类生效
	@ConditionalOnWebApplication
	
	//判断当前项目有没有这个类CharacterEncodingFilter，SpringMVC中进行乱码解决的过滤器
	@ConditionalOnClass(CharacterEncodingFilter.class)
	
	//判断配置文件中是否存在某个配置spring.http.encoding.enabled，如果不存在，判断也是成立的，因为matchIfMissing = true
	//即使我们配置文件中不配置spring.http.encoding.enabled=true，也是默认生效的
	@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true)
	
	public class HttpEncodingAutoConfiguration {
	
	  	//他已经和SpringBoot的配置文件映射了
	  	private final HttpEncodingProperties properties;
		//只有一个有参构造器的情况下，参数的值就会从容器中拿
	  	public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {
			this.properties = properties;
		}
		
		//给容器中添加一个组件，这个组件的某些值需要从properties中获取
	    @Bean
	    
	    //判断容器没有这个组件？
		@ConditionalOnMissingBean(CharacterEncodingFilter.class)
		public CharacterEncodingFilter characterEncodingFilter() {
			CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
			filter.setEncoding(this.properties.getCharset().name());
			filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));
			filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));
			return filter;
		}
	}

	根据不同的判断条件，决定这个配置类是否生效
	一但这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的

5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装的，配置文件能配置什么就可以参照某个功能对应的这个属性类

	//从配置文件中获取指定的值和bean的属性进行绑定
	@ConfigurationProperties(prefix = "spring.http.encoding")
	public class HttpEncodingProperties {
		public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8");
	}

总结：
	1）SpringBoot启动会加载大量的自动配置类
	2）我们看我们需要的功能有没有SpringBoot默认写好的自动配置类
	3）我们再来看这个自动配置类中到底配置了哪些组件（只要我们要用的组件有，我们就不需要再来配置了）
	4）给容器中自动配置类添加组件的时候，会从properties类中获取某些属性，我们就可以在配置文件中指定这些属性的值

	xxxxAutoConfigurartion：自动配置类，给容器中添加组件
	xxxxProperties：封装配置文件中相关属性

2、细节
1、@Conditional派生的注解

	作用：必须是@Conditional指定的条件成立，配置类才生效，给容器中添加组件
	@Conditional派生的注解			作用（判断是否满足当前指定条件）
	@ConditionalOnJava				系统的java版本是否符合要求
	@ConditionalOnBean				容器中存在指定Bean
	@ConditionalOnMissingBean		容器中不存在指定Bean
	@ConditionalOnClass				系统中有指定的类
	@ConditionalOnMissingClass		系统中没有指定的类
	@ConditionalOnExpression		满足SpEL表达式指定
	@ConditionalOnSingleCandidate	容器中只有一个指定的Bean，或者这个Bean是首选的
	@ConditionalOnProperty			系统中指定的属性是否有指定的值
	@ConditionalOnResource			类路径下是否存在指定资源文件
	@ConditionalOnWebApplication	当前是web环境
	@ConditionalOnNotWebApplication	当前不是web环境
	@ConditionalOnJndi				JNDI存在指定项

	自动配置类必须在一定的条件下才能生效
	
	我们怎么知道哪些自动配置类生效
	我们可以通过启用debug=true属性，来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效
	
	=========================
	AUTO-CONFIGURATION REPORT
	=========================
	
	Positive matches:（自动配置类启用的）
	        
	Negative matches:（没有启动，没有匹配成功的自动配置类）

=============================================================================
三、日志

1、市面上的日志框架
JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j....

日志门面 （抽象层）
JCL（Jakarta Commons Logging）
SLF4j（Simple Logging Facade for Java）
jboss-logging

日志实现
Log4j
Log4j2
JUL（java.util.logging）
Logback

左边选一个门面（抽象层）,右边来选一个实现

Spring用JCL
SpringBoot用 SLF4j和logback，把其他框架依赖的日志都排除了

2、SLF4j使用
	1、如何在系统中使用SLF4jhttps://www.slf4j.org
	以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法
	每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件

	2、遗留问题
	system（slf4j+logback）、Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx
	统一日志记录，让系统中所有的日志都统一到slf4j
		1、将系统中其他日志框架先排除
		2、用中间包来替换原有的日志框架
		3、导入slf4j和其实现

SpringBoot使用它来做日志功能
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-logging</artifactId>
</dependency>

如果我们要引入其他框架，一定要把这个框架依赖的日志排除

修改日志的默认配置
logging.level.root=info（默认）
logging.level.com.test=trace

# 控制台输出的日志格式
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n

# 文件中输出的日志格式
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n

logging.file	logging.path	Description            
(none)			(none)			只在控制台输出                
my.log			(none)			输出到当前项目根目录下my.log文件中，可以用绝对路径
(none)			/var/log		输出到当前磁盘根目录下var/log/spring.log文件中


2、指定配置
给类路径下放上每个日志框架自己的配置文件即可，SpringBoot就不使用他默认的配置了
Logging System			Customization                           
Logback					logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy
Log4j2					log4j2-spring.xml or log4j2.xml         
JDK (Java Util Logging)	logging.properties                      

logback.xml：直接就被日志框架识别了
logback-spring.xml：日志框架就无法识别，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能

<springProfile name="dev">
	<!-- configuration to be enabled when the "dev" profile is active -->
	可以指定某段配置只在某个环境下生效
</springProfile>

如：
<layout class="ch.qos.logback.classic.PatternLayout">
	<springProfile name="dev">
		<pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} : %msg%n</pattern>
	</springProfile>
	<springProfile name="!dev">
		<pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
	</springProfile>
</layout>

如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误
no applicable action for [springProfile]

5、切换日志框架
可以按照slf4j的日志适配图，进行相关的切换

slf4j+log4j
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
	<exclusions>
		<exclusion>
			<artifactId>logback-classic</artifactId>
			<groupId>ch.qos.logback</groupId>
		</exclusion>
		<exclusion>
			<artifactId>log4j-over-slf4j</artifactId>
			<groupId>org.slf4j</groupId>
		</exclusion>
	</exclusions>
</dependency>
<dependency>
	<groupId>org.slf4j</groupId>
	<artifactId>slf4j-log4j12</artifactId>
</dependency>

slf4j+log4j2
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
	<exclusions>
		<exclusion>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-logging</artifactId>
		</exclusion>
	</exclusions>
</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>

SpringBoot有两个日志starter
spring-boot-starter-logging（默认）
spring-boot-starter-log4j2
没有log4j，想要用log4j就要手动

=============================================================================
四、Web开发

2、静态资源映射
WebMvcAutoConfiguration
WebMvcProperties//@ConfigurationProperties(prefix = "spring.mvc")
ResourceProperties//@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)

staticPathPattern
	/**

静态资源文件夹
staticLocations
	classpath:/META-INF/resources/
	classpath:/resources/
	classpath:/static/
	classpath:/public/
	/

webjars：以jar包的方式引入静态资源

/webjars/**		classpath:/META-INF/resources/webjars/
/**				staticLocations/
**/favicon.ico	staticLocations/favicon.ico
欢迎页			staticLocations/index.html


3、模板引擎
JSP、Velocity、Freemarker、Thymeleaf
SpringBoot推荐的Thymeleaf，语法更简单，功能更强大

Simple expressions:（表达式语法）
1)Variable Expressions: ${...}，获取变量值，OGNL
	1）获取对象的属性、调用方法
	2）使用内置的基本对象
		#ctx : the context object.
		#vars: the context variables.
	    #locale : the context locale.
	    #request : (only in Web Contexts) the HttpServletRequest object.
	    #response : (only in Web Contexts) the HttpServletResponse object.
	    #session : (only in Web Contexts) the HttpSession object.
	    #servletContext : (only in Web Contexts) the ServletContext object.
	3）内置的一些工具对象

2)Selection Variable Expressions: *{...}，选择表达式：和${}在功能上是一样
	配合th:object="${session.user}：
	<div th:object="${session.user}">
		<p>Name: <span th:text="*{firstName}">Sebastian</span>.</p>
		<p>Surname: <span th:text="*{lastName}">Pepper</span>.</p>
		<p>Nationality: <span th:text="*{nationality}">Saturn</span>.</p>
	</div>

3)Message Expressions: #{...}，获取国际化内容

4)Link URL Expressions: @{...}，定义URL
	@{/order/process(execId=${execId},execType='FAST')}

5)Fragment Expressions: ~{...}：片段引用
	<div th:insert="~{commons :: main}">...</div>
    		
Literals（字面量）
	Text literals: 'one text' , 'Another one!' ,…
	Number literals: 0 , 34 , 3.0 , 12.3 ,…
	Boolean literals: true , false
	Null literal: null
	Literal tokens: one , sometext , main ,…

Text operations:（文本操作）
	String concatenation: +
	Literal substitutions: |The name is ${name}|

Arithmetic operations:（数学运算）
	Binary operators: + , - , * , / , %
	Minus sign (unary operator): -

Boolean operations:（布尔运算）
	Binary operators: and , or
	Boolean negation (unary operator): ! , not

Comparisons and equality:（比较运算）
	Comparators: > , < , >= , <= ( gt , lt , ge , le )
	Equality operators: == , != ( eq , ne )

Conditional operators:条件运算（三元运算符）
	If-then: (if) ? (then)
	If-then-else: (if) ? (then) : (else)
	Default: (value) ?: (defaultvalue)

Special tokens:
	No-Operation: _

<a id="1" th:id="${id}" th:text="${text}" th:href="@{href}">abc</a>
浏览器直接打开，浏览器不认识th语法，显示abc
经过模板引擎解析后，显示变量的内容

th:text和[[...]]转义html
th:utext和[(...)]不转义html

<html lang="en" xmlns:th="http://www.thymeleaf.org">
<ul>
	<li th:each="user : ${userList}" th:text="${user}"></li>
	<li th:each="user : ${userList}">[[${user}]]</li>
</ul>

spring.thymeleaf.cache=false

=============================================================================

4、SpringMVC自动配置

https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications

1. Spring MVC auto-configuration

SpringBoot自动配置好了SpringMVC

以下是SpringBoot对SpringMVC的默认配置:（WebMvcAutoConfiguration）

- Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.
	自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））
	ContentNegotiatingViewResolver：组合所有的视图解析器的
	如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来

- Support for serving static resources, including support for WebJars (see below).
	静态资源文件夹路径， webjars

- Static index.html support.
	静态首页访问

- Custom Favicon support (see below).
	favicon.ico
  
- 自动注册了Converter, GenericConverter, Formatter beans.
	Converter：转换器，public String hello(User user)，类型转换使用Converter
	Formatter：格式化器，2017.12.17 -> Date
	
	@Bean
	@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则
	public Formatter<Date> dateFormatter() {
		return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件
	}

	自己添加的格式化器转换器，我们只需要放在容器中即可

- Support for HttpMessageConverters (see below).
	HttpMessageConverter，SpringMVC用来转换Http请求和响应的，User -> Json
	HttpMessageConverters，是从容器中确定，获取所有的HttpMessageConverter
	自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean，@Component）
    
- Automatic registration of MessageCodesResolver (see below).
	定义错误代码生成规则

- Automatic use of a ConfigurableWebBindingInitializer bean (see below).
	我们可以配置一个ConfigurableWebBindingInitializer来替换默认的，（添加到容器）
	初始化WebDataBinder
	请求数据 -> JavaBean

org.springframework.boot.autoconfigure.web：web的所有自动场景；

If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.)
you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc.

If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components.

If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.

2、扩展SpringMVC
<mvc:view-controller path="/hello" view-name="success"/>
<mvc:interceptors>
	<mvc:interceptor>
		<mvc:mapping path="/hello"/>
		<bean></bean>
	</mvc:interceptor>
</mvc:interceptors>

编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型，不能标注@EnableWebMvc
既保留了所有的自动配置，也能用我们扩展的配置

	//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能
	@Configuration
	public class MyMvcConfig extends WebMvcConfigurerAdapter {
		@Override
		public void addViewControllers(ViewControllerRegistry registry) {
			//浏览器发送/atguigu请求来到success
			registry.addViewController("/atguigu").setViewName("success");
		}
	}

原理：
	1）WebMvcAutoConfiguration是SpringMVC的自动配置类
	2）在做其他自动配置时会导入@Import(EnableWebMvcConfiguration.class)

	@Configuration
	public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration {
		private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();

		//从容器中获取所有的WebMvcConfigurer
		@Autowired(required = false)
		public void setConfigurers(List<WebMvcConfigurer> configurers) {
			if (!CollectionUtils.isEmpty(configurers)) {
				this.configurers.addWebMvcConfigurers(configurers);
				//一个参考实现，将所有的WebMvcConfigurer相关配置都来一起调用
				@Override
				// public void addViewControllers(ViewControllerRegistry registry) {
				//    for (WebMvcConfigurer delegate : this.delegates) {
				//       delegate.addViewControllers(registry);
				//   }
			}
		}
	}
	
	3）容器中所有的WebMvcConfigurer都会一起起作用
	4）我们的配置类也会被调用

	效果：SpringMVC的自动配置和我们的扩展配置都会起作用

3、全面接管SpringMVC

SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置，所有的SpringMVC的自动配置都失效了

我们需要在配置类中添加@EnableWebMvc即可

	@EnableWebMvc
	@Configuration
	public class MyMvcConfig extends WebMvcConfigurerAdapter {
		@Override
		public void addViewControllers(ViewControllerRegistry registry) {
			//浏览器发送/atguigu请求来到success
			registry.addViewController("/atguigu").setViewName("success");
		}
	}

原理：

为什么@EnableWebMvc自动配置就失效了

1）@EnableWebMvc的核心
    @Import(DelegatingWebMvcConfiguration.class)
    public @interface EnableWebMvc {

2）
    @Configuration
    public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {

3）
    @Configuration
    @ConditionalOnWebApplication
    @ConditionalOnClass({Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class})
    //容器中没有这个组件的时候，这个自动配置类才生效
    @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
    @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
    @AutoConfigureAfter({DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class})
    public class WebMvcAutoConfiguration {

4）@EnableWebMvc将WebMvcConfigurationSupport组件导入进来

5）导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能

5、如何修改SpringBoot的默认配置

模式：
	1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；
		如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；
	2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置
	3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置

6、RestfulCRUD

1）、默认访问首页
	@Configuration
	public class MyMvcConfig {
		@Bean
		public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){
			WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() {
				@Override
				public void addViewControllers(ViewControllerRegistry registry) {
					registry.addViewController("/").setViewName("login");
					registry.addViewController("/index.html").setViewName("login");
				}
			};
			return adapter;
		}
	}

2）国际化
	1）编写国际化配置文件
	2）使用ResourceBundleMessageSource管理国际化资源文件
	3）在页面使用#{...}取出国际化内容

步骤：
1）编写国际化配置文件，抽取页面需要显示的国际化信息
2）SpringBoot自动配置好了管理国际化资源文件的组件

    @ConfigurationProperties(prefix = "spring.messages")
    public class MessageSourceAutoConfiguration {
		/**
		 * Comma-separated list of basenames (essentially a fully-qualified classpath
		 * location), each following the ResourceBundle convention with relaxed support for
		 * slash based locations. If it doesn't contain a package qualifier (such as
		 * "org.mypackage"), it will be resolved from the classpath root.
		 */
		private String basename = "messages";  
		//我们的配置文件可以直接放在类路径下叫messages.properties
		
		@Bean
		public MessageSource messageSource() {
			ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
			if (StringUtils.hasText(this.basename)) {
				//设置国际化资源文件的基础名（去掉语言国家代码的）
				messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(this.basename)));
			}
			if (this.encoding != null) {
				messageSource.setDefaultEncoding(this.encoding.name());
			}
			messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale);
			messageSource.setCacheSeconds(this.cacheSeconds);
			messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat);
			return messageSource;
		}
	}

spring.messages.basename=i18n.login

3）、去页面获取国际化的值
	<button th:text="#{login.btn}">Sign in</button>

	默认根据浏览器语言设置的信息切换国际化

原理：
	Locale（区域信息对象）
	LocaleResolver（获取区域信息对象）

	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnProperty(prefix = "spring.mvc", name = "locale")
	public LocaleResolver localeResolver() {
		if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {
			return new FixedLocaleResolver(this.mvcProperties.getLocale());
		}
		AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
		localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
		return localeResolver;
	}
	
	默认是根据请求头带来的区域信息获取Locale进行国际化

4）、点击链接切换国际化

	/**
	 * 可以在请求上携带区域信息
	 */
	public class MyLocaleResolver implements LocaleResolver {
		@Override
		public Locale resolveLocale(HttpServletRequest request) {
			String l = request.getParameter("l");
			Locale locale = Locale.getDefault();
			if(!StringUtils.isEmpty(l)){
				String[] split = l.split("_");
				locale = new Locale(split[0],split[1]);
			}
			return locale;
		}
		
		@Override
		public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {
		}
	}
	
	@Bean
	public LocaleResolver localeResolver(){
		return new MyLocaleResolver();
	}

3）、登陆

开发期间模板引擎页面修改以后，要实时生效

1）禁用模板引擎的缓存
	spring.thymeleaf.cache=false

2）页面修改完成以后ctrl+f9，重新编译

登陆错误消息的显示
    <p style="color: red" th:text="${msg}" th:if="${not #strings.isEmpty(msg)}"></p>

4）、拦截器进行登陆检查

定义拦截器

	/**
	 * 登陆检查
	 */
	public class LoginHandlerInterceptor implements HandlerInterceptor {
		//目标方法执行之前
		@Override
		public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
			Object user = request.getSession().getAttribute("loginUser");
			if(user == null){
				//未登陆，返回登陆页面
				request.setAttribute("msg", "没有权限请先登陆");
				request.getRequestDispatcher("/index.html").forward(request,response);
				return false;
			}else{
				//已登陆，放行请求
				return true;
			}
		}
		
		@Override
		public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
		}
		
		@Override
		public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
		}
	}

添加拦截器

	@Bean
	public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){
		WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() {
			//添加拦截器
			@Override
			public void addInterceptors(InterceptorRegistry registry) {
				//SpringBoot已经做好了静态资源映射*.css, *.js
				registry.addInterceptor(new LoginHandlerInterceptor())
					.addPathPatterns("/**")
					.excludePathPatterns("/index.html", "/", "/user/login");
			}
		};
		return adapter;
	}

5）CRUD-员工列表

1）RestfulCRUD：CRUD满足Rest风格

URI：  /资源名称/资源标识       HTTP请求方式区分对资源CRUD操作

      	普通CRUD（uri来区分操作）	RestfulCRUD      
查询		getEmp                 	emp/{id}---GET        
添加		addEmp?xxx             	emp---POST       
修改		updateEmp?id=xxx&xxx=xx	emp/{id}---PUT   
删除		deleteEmp?id=1         	emp/{id}---DELETE

7、错误处理机制

1）、SpringBoot默认的错误处理机制

默认效果：
	1）浏览器，返回一个默认的错误页面
		浏览器发送请求的请求头：Accept: text/html
	2）如果是其他客户端，默认响应一个json数据

原理：
	可以参照ErrorMvcAutoConfiguration，错误处理的自动配置
	
	给容器中添加了以下组件
	1、DefaultErrorAttributes
	2、BasicErrorController，处理默认/error请求
	3、ErrorPageCustomizer
	4、DefaultErrorViewResolver

1）、如何定制错误的页面；

	1）、有模板引擎的情况下，error/状态码，将错误页面命名为，错误状态码.html，放在模板引擎文件夹里面的 error文件夹下，发生此状态码的错误就会来到，对应的页面
		我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）	
	
		页面能获取的信息
			timestamp：时间戳
			status：状态码
			error：错误提示
			exception：异常对象
			message：异常消息
			errors：JSR303数据校验的错误都在这里
	
	2）、没有模板引擎，静态资源文件夹下找
	
	3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面

2）、如何定制错误的json数据

	1）、自定义异常处理&返回定制json数据

	@ControllerAdvice
	public class MyExceptionHandler {
		@ResponseBody
		@ExceptionHandler(UserNotExistException.class)
		public Map<String,Object> handleException(Exception e){
			Map<String, Object> map = new HashMap<>();
			map.put("code", "user.notexist");
			map.put("message", e.getMessage());
			return map;
		}
	}
	
	//没有自适应效果...
	
	2）、转发到/error进行自适应响应效果处理

	@ExceptionHandler(UserNotExistException.class)
	public String handleException(Exception e, HttpServletRequest request){
		Map<String,Object> map = new HashMap<>();
		//传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程
		request.setAttribute("javax.servlet.error.status_code", 500);
		map.put("code", "user.notexist");
		map.put("message", e.getMessage());
		//转发到/error
		return "forward:/error";
	}

3）、将我们的定制数据携带出去

出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；

	1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中

	2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到

		容器中DefaultErrorAttributes.getErrorAttributes()，默认进行数据处理的

自定义ErrorAttributes

    //给容器中加入我们自己定义的ErrorAttributes
    @Component
    public class MyErrorAttributes extends DefaultErrorAttributes {
        @Override
        public Map<String, Object> getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) {
            Map<String, Object> map = super.getErrorAttributes(requestAttributes, includeStackTrace);
            map.put("company", "atguigu");
            return map;
        }
    }

最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容

8、配置嵌入式Servlet容器

1）如何定制和修改Servlet容器的相关配置

1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；

    server.port=8081
    server.context-path=/crud
    
    server.tomcat.uri-encoding=UTF-8
    
    //通用的Servlet容器设置
    server.xxx
    
    //Tomcat的设置
    server.tomcat.xxx

2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器，来修改Servlet容器的配置

	//一定要将这个定制器加入到容器中
    @Bean
    public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){
        return new EmbeddedServletContainerCustomizer() {
            //定制嵌入式的Servlet容器相关的规则
            @Override
            public void customize(ConfigurableEmbeddedServletContainer container) {
                container.setPort(8083);
            }
        };
    }

2）、注册Servlet三大组件

由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件

用以下方式

	//Servlet
    @Bean
    public ServletRegistrationBean myServlet(){
        ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(), "/myServlet");
        return registrationBean;
    }

	//Filter
    @Bean
    public FilterRegistrationBean myFilter(){
        FilterRegistrationBean registrationBean = new FilterRegistrationBean();
        registrationBean.setFilter(new MyFilter());
        registrationBean.setUrlPatterns(Arrays.asList("/hello", "/myServlet"));
        return registrationBean;
    }

	//Listener
    @Bean
    public ServletListenerRegistrationBean myListener(){
        ServletListenerRegistrationBean<MyListener> registrationBean = new ServletListenerRegistrationBean<>(new MyListener());
        return registrationBean;
    }

SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器，DispatcherServlet

DispatcherServletAutoConfiguration中：
//默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp
//可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径

2）、SpringBoot能不能支持其他的Servlet容器

3）、替换为其他嵌入式Servlet容器

默认支持：

Tomcat（默认使用）

    <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
	引入的web模块默认就是使用嵌入式的Tomcat作为Servlet容器

Jetty

    <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-web</artifactId>
       <exclusions>
          <exclusion>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-tomcat</artifactId>
          </exclusion>
       </exclusions>
    </dependency>
    
    <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-jetty</artifactId>
    </dependency>

Undertow

    <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-web</artifactId>
       <exclusions>
          <exclusion>
             <artifactId>spring-boot-starter-tomcat</artifactId>
             <groupId>org.springframework.boot</groupId>
          </exclusion>
       </exclusions>
    </dependency>
    
    <dependency>
       <artifactId>spring-boot-starter-undertow</artifactId>
       <groupId>org.springframework.boot</groupId>
    </dependency>

9、使用外置的Servlet容器

嵌入式Servlet容器：应用打成可执行的jar
	优点：简单、便携；
	缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；

外置的Servlet容器：外面安装Tomcat---应用war包的方式打包

步骤
1）、必须创建一个war项目（利用idea创建好目录结构）

2）、将嵌入式的Tomcat指定为provided

	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-tomcat</artifactId>
		<scope>provided</scope>
	</dependency>

3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法

    public class ServletInitializer extends SpringBootServletInitializer {
       @Override
       protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
           //传入SpringBoot应用的主程序
          return application.sources(SpringBoot04WebJspApplication.class);
       }
    }

4）、启动服务器就可以使用

原理

jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器

war包：启动服务器，服务器再启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器

=============================================================================

五、Docker

1、简介
Docker是一个开源的应用容器引擎，是一个轻量级容器技术
Docker支持将做好配置的软件编译成一个镜像，将镜像发布出去，其他使用者可以直接使用这个镜像，就像系统镜像一样
运行中的这个镜像称为容器，容器启动是非常快速的。

2、核心概念
docker客户端(Client)：	连接docker主机进行操作
docker主机(Host)：		安装了Docker程序的机器（Docker直接安装在操作系统之上）
docker镜像(Images)：		软件打包好的镜像，放在docker仓库中
docker容器(Container)：	镜像启动后的实例称为一个容器，容器是独立运行的一个或一组应用
docker仓库(Registry)：	用来保存各种打包好的软件镜像

使用Docker的步骤：
1）安装Docker
2）去Docker仓库找到这个软件对应的镜像，hub.docker.com或者docker search xxx
3）使用Docker运行这个镜像，这个镜像就会生成一个Docker容器
4）对容器的启动停止就是对软件的启动停止

3、安装Docker

1）安装linux虚拟机
	1）VMWare、VirtualBox
	2）导入虚拟机文件centos7-atguigu.ova
	3）双击启动linux虚拟机，使用 root/123456登陆
	4）设置虚拟机网络，桥接网络，选好网卡，接入网线
	5）设置好网络以后使用命令重启虚拟机的网络service network restart
	6）查看linux的ip地址，ip addr
	7）使用客户端连接linux服务器进行命令操作

2）在linux虚拟机上安装docker
	1）检查内核版本，必须是3.10及以上
		uname -r，若否，yum update
	2）安装docker
		yum -y install docker
	3）启动docker
		systemctl start docker
		docker -v
	5）开机启动docker
		systemctl enable docker
	6）停止docker
		systemctl stop docker

4、Docker常用命令&操作

1）、镜像操作

docker search xxx						搜索镜像
docker pull 镜像名[:tag]					下载镜像（:tag是标签，多为软件的版本，不加默认是latest）
docker images							查看本地镜像                
docker rmi image-id						删除本地镜像
docker rm container-id/name				删除容器
docker stop container-id/name			停止容器
docker start container-id/name			启动容器
docker ps								查看运行中的容器
docker ps -a							查看所有的容器
docker logs container-id/name			查看容器的日志

docker run --name mytomcat -d -p 8888:8080 tomcat:latest
	-d：后台运行
	-p: 将主机的端口映射到容器的一个端口，主机端口:容器内部的端口

service firewalld status				查看防火墙状态
service firewalld stop					关闭防火墙

docker images的official表示是否官方，automated表示配置好的

更多命令参看
	https://docs.docker.com/engine/reference/commandline/docker/

可以参考每一个镜像的文档安装镜像，如mysql需要设置密码

3）安装MySQL
    docker pull mysql
	docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d -p 3306:3306 mysql
	
	docker logs 42f09819908b
	error: database is uninitialized and password option is not specified 
	You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个

几个其他的高级操作

    docker run --name mysql01 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d -p 3306:3306 mysql:tag
	把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面
	改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）
    
    docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d -p 3306:3306 mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
	指定mysql的一些配置参数

=============================================================================

六、SpringBoot与数据访问

1、JDBC
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-jdbc</artifactId>
	</dependency>
	<dependency>
		<groupId>mysql</groupId>
		<artifactId>mysql-connector-java</artifactId>
		<scope>runtime</scope>
	</dependency>

    spring:
      datasource:
        driver-class-name: com.mysql.jdbc.Driver
        url: jdbc:mysql://localhost:3306/jdbc
        username: root
        password: 123456

	默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源
	数据源的相关配置都在DataSourceProperties里面

自动配置原理：

org.springframework.boot.autoconfigure.jdbc

DataSourceAutoConfiguration
1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型

2、SpringBoot默认支持
	org.apache.tomcat.jdbc.pool.DataSource
	org.apache.commons.dbcp.BasicDataSource
	org.apache.commons.dbcp2.BasicDataSource
	com.zaxxer.hikari.HikariDataSource
	
3、自定义数据源类型

    /**
     * Generic DataSource configuration.
     */
    @ConditionalOnMissingBean(DataSource.class)
    @ConditionalOnProperty(name = "spring.datasource.type")
    static class Generic {
       @Bean
       public DataSource dataSource(DataSourceProperties properties) {
           //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性
          return properties.initializeDataSourceBuilder().build();
       }
    }

4、DataSourceInitializer：ApplicationListener

	1）、runSchemaScripts()，运行建表语句，schema-*.sql（schema.sql，schema-all.sql）
	2）、runDataScripts()，运行插入数据的sql语句，data-*.sql
	
	也可以在配置文件中指定位置
    	spring:
    	  datasource:
    	    schema:
		      - classpath: department.sql

5、操作数据库：自动配置了JdbcTemplate操作数据库

2、整合Druid数据源

    @Configuration
    public class DruidConfig {
        @ConfigurationProperties(prefix = "spring.datasource")
        @Bean
        public DataSource druid(){
           return new DruidDataSource();
        }
    }

3、整合MyBatis
	
	mybatis自己的starter，不是spring的
	<dependency>
		<groupId>org.mybatis.spring.boot</groupId>
		<artifactId>mybatis-spring-boot-starter</artifactId>
		<version>1.3.1</version>
	</dependency>
	
	要么给每个Mapper接口加上@Mapper，要么在主配置类上加@MapperScan(value = "com.test.mapper")

	mybatis:
		config-location: classpath:mybatis/mybatis-config.xml	指定全局配置文件的位置
		mapper-locations: classpath:mybatis/mapper/*.xml		指定sql映射文件的位置

更多使用参照
	http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/

4、整合SpringData JPA

1）、SpringData简介

2）、整合SpringData JPA

JPA（Java Persistence API）
ORM（Object Relational Mapping）

1）、编写一个实体类和数据表进行映射
2）、编写一个Dao接口继承JpaRepository来完成对数据库的操作

JpaProperties

	spring:
	  jpa:
	    hibernate:
          ddl-auto: update #更新或者创建数据表结构
        show-sql: true #控制台显示SQL

=============================================================================

七、启动配置原理




=============================================================================
=============================================================================
=============================================================================
=============================================================================
=============================================================================
RabbitMQ

JMS(Java Message Service)
ActiveMQ

AMQP(Advanced Message Queuing Protocol)
RabbitMQ

		JMS				AMQP
定义		Java Api		网络协议
跨语言	否				是
跨平台	否				是
Model	peer-2-peer		direct exchange
		pub/sub			fanout exchange
						topic exchange
						headers exchange
						system exchange
消息类型	TextMessage		byte[]将消息序列化后发送
		MapMessage
		BytesMessage
		StreamMessage
		ObjectMessage
		Message

消息中的路由键（Routing Key）和Binding中的Routing Key比较

点对点		direct		只发给一个队列
发布/订阅	fanout		发给绑定的所有队列，不使用路由键
			topic		使用路由键进行模式匹配，#匹配0个或多个单词，*匹配一个单词，单词之间用.隔开
			headers		用的少，匹配消息头，而不是路由键

Message			消息，由消息头和消息体组成
Publisher		消息的生产者
Exchange		交换器，接收消息并发送到列队中
Queue			消息队列
Binding			交换器和消息队列的绑定关系，决定了消息会发送到哪个队列，一个交换器可以绑定多个队列，一个队列可以被多个交换器绑定
Connection		TCP连接
Channel			信道，一条独立的双向数据流通道，是建立在真实TCP连接内的虚拟连接，AMQP命令都是通过信道发出去的，对于操作系统来说，建立和销毁TCP连接开销大，所以采用信道，复用一个TCP连接
Consumer		消息的消费者
Virtual Host	虚拟主机，mini版的RabbitMQ，可独立运行，每个vhost拥有自己的交换器、队列、绑定和权限机制，连接时必须指定，默认/
Broker			消息服务器实体


JmsTemplate				RabbitTemplate
@JmsListener			@RabbitListener
@EnableJms				@EnableRabbit
@JmsAutoConfiguration	@RabbitAutoConfiguration

=============================================================================
ElasticSearch

开源
全文搜索引擎的首选
快速地储存、搜索和分析海量数据
底层基于开源库Lucene
但是，你没法直接用Lucene，必须自己写代码去调用它的接口
ES是Lucene的封装，提供了REST API的操作接口，开箱即用
Spring Data ElasticSearch提供了非常便捷的检索功能的支持
分布式搜索服务
采用多shard（分片）的方式保证数据安全，并且提供自动resharding的功能，github等大型的站点也采用ES

ES_JAVA_OPTS="-Xms256m -Xmx256m"

9200	服务
9300	节点之间通信

安装spring-data-elasticsearch对应版本的elasticsearch
spring data elasticsearch	elasticsearch
3.2.x	6.5.0
3.1.x	6.2.2
3.0.x	5.5.0
2.1.x	2.4.0
2.0.x	2.2.0
1.3.x	1.5.2

两种方式操作ES
1、jest
2、spring-data-elasticsearch
	Client
	ElasticsearchRepository
	ElasticsearchTemplate

https://github.com/spring-projects/spring-data-elasticsearch
https://github.com/searchbox-io/Jest/tree/master/jest

https://docs.spring.io/spring-data/elasticsearch/docs/2.1.18.RELEASE/reference/html/

安装服务，6版本参考官网
service.bat install elasticsearch-2.4.6

安装head插件
plugin install mobz/elasticsearch-head
http://localhost:9200/_plugin/head/

=============================================================================
任务

1、异步任务
	@EnableAsync
	@Async

2、定时任务
	@EnableScheduling
	@Scheduled(cron = "0/4 * * * * MON-SAT")
	
	second(秒), minute（分）, hour（时）, day of month（日）, month（月）, day of week（星期）
	
	日和星期不能同时*，一个*，另一个就要么？，要么具体值
	1-6是星期一到六，0和7是星期天
	, 枚举
	- 范围
	* 任意
	/ 步长
	? 日和星期冲突匹配
	L 最后
	W 工作日
	# 3#2，第2个星期三

3、邮件任务
	JavaMailSender
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-mail</artifactId>
	</dependency>

=============================================================================
安全

认证（Authentication）

授权（Authorization）

视频里是和thymeleaf整合使用

=============================================================================
热部署

第一个没加，在springcloud视频里有加
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>springloaded</artifactId>
</dependency>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-devtools</artifactId>
	<scope>runtime</scope>
	<optional>true</optional>
</dependency>

=============================================================================
监管

autoconfig	所有自动配置信息
auditevents	审计事件
beans		所有Bean的信息
configprops	所有配置属性
dump		线程状态信息
env			当前环境信息
health		应用健康状况
info		当前应用信息
metrics		应用的各项指标
mappings	应用@RequestMapping映射路径
shutdown	关闭当前应用（默认关闭）
trace		追踪信息（最新的http请求）
